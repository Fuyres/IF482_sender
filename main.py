# The IF482 Generator needs an high precise 1 Hz clock signal which cannot be
# acquired in suitable precision on the ESP32 SoC itself. Additional clocking
# hardware is required, ususally the clock signal is generated by external RTC or
# GPS which can generate a precise time pulse signal (+/- 2ppm).

# In this example code we use a Maxim DS3231 RTC chip, and configure the chips's
# interrupt output pin as clock. The clock signal triggers an interrupt on the
# ESP32, which controls the realtime output of IF482 telegram. This is why code in
# IF482.cpp depends on code in RTCTIME.cpp.

# ///////////////////////////////////////////////////////////////////////////////

# IF482 Generator to control clocks with IF482 telegram input (e.g. BÜRK BU190)

# Example IF482 telegram: "OAL160806F170400"

# IF482 Specification:
# http://www.mobatime.com/fileadmin/user_upload/downloads/TE-112023.pdf

# The IF 482 telegram is a time telegram, which sends the time and date
# information as ASCII characters through the serial interface RS 232 or RS 422.

# Communication parameters:

# Baud rate: 9600 Bit/s
# Data bits 7
# Parity: even
# Stop bit: 1
# Jitter: < 50ms

# Interface : RS232 or RS422

# Synchronization: Telegram ends at the beginning of the second
# specified in the telegram

# Cycle: 1 second

# Format of ASCII telegram string:

# Byte  Meaning             ASCII     Hex
#  1    Start of telegram   O         4F
#  2    Monitoring*         A         41
#  3    Time-Season**       W/S/U/L   57 or 53
#  4    Year tens           0 .. 9    30 .. 39
#  5    Year unit           0 .. 9    30 .. 39
#  6    Month tens          0 or 1    30 or 31
#  7    Month unit          0 .. 9    30 .. 39
#  8    Day tens            0 .. 3    30 .. 33
#  9    Day unit            0 .. 9    30 .. 39
# 10    Day of week***      1 .. 7    31 .. 37
# 11    Hours tens          0 .. 2    30 .. 32
# 12    Hours unit          0 .. 9    30 .. 39
# 13    Minutes tens        0 .. 5    30 .. 35
# 14    Minutes unit        0 .. 9    30 .. 39
# 15    Seconds tens        0 .. 5    30 .. 35
# 16    Seconds unit        0 .. 9    30 .. 39
# 17    End of telegram     CR        0D

# *) Monitoring:
# With a correctly received time in the sender unit, the ASCII character 'A' is
# issued. If 'M' is issued, this indicates that the sender was unable to receive
# any time signal for over 12 hours (time is accepted with ‘A’ and ‘M’).

# **) Season:
# W: Standard time,
# S: Season time,
# U: UTC time (not supported by all systems),
# L: Local Time

# ***) Day of week:
# not evaluated by model BU-190, use "F" instead for this model

# ///////////////////////////////////////////////////////////////////////////////
from sys import platform
import argparse
import os
import sys
import time
#import datetime
from datetime import datetime

file_path = 'serial/'
sys.path.append(os.path.dirname(file_path))
import serial
import serial.tools.list_ports


class SerialRun(object):
    def __init__(self, serialport="COM3", cmd='/#6'):
        self.SerialPort = serialport
        self.ReadBaudrate = 9600
        self.WriteBaundrate = 9600
        self.SerCon = None
        self.cmd_id = cmd

    def connect(self):
        self.SerCon = serial.Serial(
            port=self.SerialPort,
            baudrate=9600,
            timeout=5.0,
            bytesize=serial.SEVENBITS,
            parity=serial.PARITY_EVEN,
            stopbits=serial.STOPBITS_ONE)

        print("Connected to Serial Port: " + self.SerCon.portstr)
        return self.SerCon.is_open

    def disconnect(self):
        if self.SerCon.is_open:
            self.SerCon.close()

    def run(self):
        if self.connect():
            # bytes_command = command_list.cmd_dict[self.cmd_id].cmd.encode()
            # CommandsDEC[self.cmd_id].encode()
            #self.send_command(bytes_command)

            # print("get string")
            # buffer_str = self.read_bytes(command_list.cmd_dict[self.cmd_id].LenData)
            # self.read_bytes(LenData[self.cmd_id])

            return "" #buffer_str

    def get_strings(self):
        str = self.run()
        print("====text buffer=====")
        print(str)
        print("====text buffer=====")

    def get_str(self):
        str0 = self.run()
        str1 = ""
        if len(str0) > 0:
            str1, str_tag = str0
        return str1

    def get_json(self, str0):
        str1 = ""
        if len(str0) > 0:
            str1 = str0
        return str1

    def read_bytes(self, lines=1):
        self.SerCon.baudrate = self.ReadBaudrate
        # print("Set Read baudrate: ", self.SerCon.baudrate)

        # buffer_str += "\n"
        # print("buffer_str:", buffer_str)

        # read LINES
        j = 0
        reading_ba = bytearray()
        reading_ba_line = bytearray()
        # reading_ba_out = bytearray()

        while j < lines:
            for buffer in self.SerCon.read():
                reading_ba.append(buffer)
                reading_ba_line.append(buffer)
                if buffer == 0x0D:  # dot
                    j += 1
                    # reading_ba_out += reading_ba
                    print("xl:", j, reading_ba_line)
                    reading_ba_line = bytearray()

            # print("reading:", reading_ba)
            # print("reading2:", reading_ba_out.de)

        self.disconnect()

        # buffer_str += reading_ba_out.decode()
        # str1 = reading_ba_out.decode()
        buffer_str = ""
        buffer_str += reading_ba.decode()

        # str1 = str1.replace('\r', '\n')
        buffer_str = buffer_str.replace('\r', '\n')
        buffer_str = buffer_str[:3] + '\n' + buffer_str[3:]

        # print("buffer_str: \n", buffer_str)
        return buffer_str

    def send_command(self, comd):
        self.SerCon.baudrate = self.WriteBaundrate
        # print("Set Write baudrate: ", self.SerCon.baudrate)
        self.SerCon.write(comd)
        time.sleep(1)


def portIsUsable(portName):
    try:
        ser = serial.Serial(port=portName)
        return True
    except:
        return False





if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     epilog="IF-482 Sender")
    parser.add_argument("-d", "--device", type=str, help="Serial port for IF-482. Example: "
                                                         "/dev/ttyS1 or COM1 or test", required=True)
    # parser.add_argument("--verbose", help="Make this script more verbose", action="store_true")

    args = parser.parse_args()

    if args.device != 'test':

        SerialPortsTuple = [tuple(p) for p in list(serial.tools.list_ports.comports())]
        print(SerialPortsTuple)

        # check if serial port exist
        SerialFound = ""
        for i in range(0, len(SerialPortsTuple)):
            if SerialPortsTuple[i][0] == args.device:
                print("Device was found successful: %s" % SerialPortsTuple[i][1])
                SerialFound = SerialPortsTuple[i][0]

        if len(SerialFound) < 1:
            print("Error! failed to locate specified device: %s" % args.device)
            sys.exit(1)

        # check if serial port busy
        if portIsUsable(args.device):
            print("Port is not busy.")
        else:
            print("Port is Busy!")
            sys.exit(1)

    SerCon = serial.Serial(
        port=args.device,
        baudrate=9600,
        timeout=5.0,
        bytesize=serial.SEVENBITS,
        parity=serial.PARITY_EVEN,
        stopbits=serial.STOPBITS_ONE)

    SerCon.open()

    while True:
        now = datetime.now()
        tgrm_f_str = "OAS" + now.strftime("%y%m%d%u%H%M%S") + "\r"
        str_1_encoded = tgrm_f_str.encode(encoding='ascii')

        print("telegram: ", tgrm_f_str)
        # printing individual bytes
        for bytes in str_1_encoded:
            print("bytes: ", hex(bytes), end=' ')

        SerCon.write(str_1_encoded)

        #x = ser.read()  # read one byte
        #s = ser.read(10)  # read up to ten bytes (timeout)
        line = SerCon.readline()  # read a '\n' terminated line
        print("read: ", line)

        time.sleep(1)

    SerCon.close()







    #now = datetime.now()
    #tgrm_f_str = "OAL " + now.strftime("%y %m %d %u %H %M %S") + "\r"
    #print("telegram", tgrm_f_str)

    #tgrm_f_str = "OAS" + now.strftime("%y%m%d%u%H%M%S") + "\r"
    #print("telegram", tgrm_f_str)

    # Using the encode method
    #str_1 = tgrm_f_str

    #str_1_encoded = str_1.encode(encoding='ascii')

    # printing the encode string
    #print(str_1_encoded)

    # printing individual bytes
    #for bytes in str_1_encoded:
    #    print(bytes, end=' ')

    #print("\n")

    #for bytes in str_1_encoded:
    #    print(hex(bytes), end=' ')

###############################\
# for c in test:
#    print(hex(ord(c)))

# To convert:

# output = ''.join(hex(ord(c)) for c in test)

# or without the '0x' in output:

# output = ''.join(hex(ord(c))[2:] for c in test)
